/*
 * Copyright (c) 2012-2020 Institut National des Sciences Appliqu√©es de Lyon (INSA Lyon) and others
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 */

package gololang.ir;

import java.util.Collections;
import java.util.List;

public abstract class GoloAssignment<T extends GoloAssignment<T>> extends GoloStatement<T> implements ReferencesHolder {

  private boolean declaring = false;
  private ExpressionStatement<?> expressionStatement;

  GoloAssignment() { super(); }

  /**
   * Checks if this assignment is a declaring one.
   *
   * @see #declaring()
   */
  public final boolean isDeclaring() {
    return declaring;
  }

  /**
   * Defines if this assignment is a declaring one.
   *
   * A declaring assignment is one that first defines the value of a reference,
   * that is a {@code let} or {@code var} assignment. An assignment to a previously defined
   * mutable variable (one declared with {@code var}) is not a declaring assignment.
   *
   * <p>This is a builder method.
   *
   * @param isDeclaring whether the assignment is declaring.
   * @return this assignment
   */
  public final T declaring(boolean isDeclaring) {
    this.declaring = isDeclaring;
    return self();
  }

  /**
   * Makes this assignment a declaring one.
   * <p>
   * Same as {@code declaring(true)}.
   *
   * @return this assignment
   */
  public final T declaring() {
    return this.declaring(true);
  }

  /**
   * Makes this assignment variable.
   *
   * @see LocalReference#variable()
   */
  public abstract T variable();

  /**
   * Checks if this assignment is constant.
   *
   * @see LocalReference#isConstant()
   */
  public abstract boolean isConstant();

  public final ExpressionStatement<?> expression() {
    return this.expressionStatement;
  }

  /**
   * Defines the value to be assigned.
   *
   * <p>This is a builder method.
   *
   * @param expr the {@link ExpressionStatement} to assign or an object that can be converted into an expression
   * @return this assignment
   * @see ExpressionStatement#of(Object)
   */
  public final T as(Object expr) {
    this.expressionStatement = makeParentOf(ExpressionStatement.of(expr));
    return self();
  }

  /**
   * Defines the references to which assign the expression.
   *
   * <p>This is a builder method.
   * <p>For instance, code like:
   * <pre class="listing"><code class="lang-golo" data-lang="golo">
   *  foo = 42
   * </code></pre>
   * can be generated by:
   * <pre class"listing"><code class="lang-java" data-lang="java">
   * assign(constant(42)).to(localRef("foo"))
   * </code></pre>
   * or using implicit conversions:
   * <pre class"listing"><code class="lang-java" data-lang="java">
   * assign(42).to("foo")
   * </code></pre>
   *
   * @param refs the {@link gololang.ir.LocalReference}s to assign to
   * @return this assignment
   */
  public abstract T to(Object... refs);


  /**
   * {@inheritDoc}
   */
  @Override
  public LocalReference[] getDeclaringReferences() {
    if (declaring) {
      return getReferences();
    }
    return new LocalReference[0];
  }

  /**
   * {@inheritDoc}
   */
  @Override
  protected void replaceElement(GoloElement<?> original, GoloElement<?> newElement) {
    if (original.equals(expression()) && newElement instanceof ExpressionStatement) {
      as(newElement);
    } else {
      throw cantReplace(original, newElement);
    }
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public List<GoloElement<?>> children() {
    return Collections.singletonList(expressionStatement);
  }
}
